'use strict';

const
  logger = require('winston'),
  express = require('express'),
  helmet = require('helmet'),
  path = require('path'),
  httpLogger = require('morgan'),
  cookieParser = require('cookie-parser'),
  bodyParser = require('body-parser'),
  expressJWT = require('express-jwt'),
  fileUpload = require('express-fileupload'),
  Bluebird = require('bluebird'),
  ObjectID = require('mongodb').ObjectID,
  nodemailer = require('nodemailer'),
  moment = require('moment'),
  { merge } = require('lodash'),
  { readFileSync, writeFileSync } = require('fs');

console.log('.-.  .-..---.  .---. .----. .----.   .--.   .----..-..-.   \n' +
  ' \\ \\/ //   __}/   __}| {}  \\| {}  } / {} \\ { {__  | || |   \n' +
  '  }  { \\  {_ }\\  {_ }|     /| .-. \\/  /\\  \\.-._} }| || `--.\n' +
  '  `--\'  `---\'  `---\' `----\' `-\' `-\'`-\'  `-\'`----\' `-\'`----\'');


// Yggdrasil is an express instance
let yggdrasil = express();

/**
 * Configuration loader
 * @param jsonConfig -  the specific json configuration (allow specific config for testing purposes)
 */
yggdrasil.loadConfig = jsonConfig => {
  if (jsonConfig) {
    yggdrasil.config = jsonConfig;
  } else {
    yggdrasil.config = require('rc')('yggdrasil', require('./defaultConfig'));
  }
};

/**
 * Returns an UUID generated by Mongo ObjectID
 * returns a real ObjectID
 * @param {boolean} returnString -  if true, send the hex string from ObjectID
 * @returns {string|ObjectID}
 */
yggdrasil.uuid = (returnString = false) => {
  let theUuid = new ObjectID();
  if (!returnString) {
    return theUuid;
  }
  return theUuid.toHexString();
};

/** Load the main Lib **/
yggdrasil.lib = require('./lib');

/***********************************************************************************************************************
 *
 * YGGDRASIL DEFINE METHODS TO INSTANTIATE CORE COMPONENTS
 *
 **********************************************************************************************************************/
yggdrasil.startup = {
  instantiate: (config) => {
    /**
     * Instantiate core services
     */
    /** Load the config **/
    console.time('time: ⏲  Pre-startup took');
    console.time('time: ⏲  Load config took');
    yggdrasil.loadConfig(config);
    console.timeEnd('time: ⏲  Load config took');

    /** Instantiate and configure the logger **/
    yggdrasil.logger = logger;
    yggdrasil.logger.level = yggdrasil.config.logger.level || 'silly';

    /** Prepares the yggdrasil to be served if needed **/
    yggdrasil.server = {};

    /** Adds events capabilities to the yggdrasil **/
    yggdrasil.events = new yggdrasil.lib.controllers.events(yggdrasil); // adds some methods to yggdrasil as shortcuts: see controller

    /** Define storage providers **/
    console.time('time: ⏲  Defining Storages took');
    yggdrasil.storage = {
      mongo: new yggdrasil.lib.drivers.mongo(yggdrasil, yggdrasil.config.mongo),
      redis: new yggdrasil.lib.drivers.redis(yggdrasil, yggdrasil.config.redis),
      isConnected: false
    };
    console.timeEnd('time: ⏲  Defining Storages took');

    if (yggdrasil.config.proxyMesh.activated) {
      yggdrasil.proxy = new yggdrasil.lib.drivers.proxyMesh(yggdrasil);
      yggdrasil.logger.info('⚙  ProxyMesh instantiated');
    }

    yggdrasil.logger.info('⚡ New yggdrasil ready to be instantiated...');
    console.timeEnd('time: ⏲  Pre-startup took');

    console.time('time: ⏲  yggdrasil instantiation took');
    return yggdrasil.storage.mongo.connect()
      .then(() => yggdrasil.storage.redis.connect())
      .catch(e => {
        yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
        yggdrasil.logger.error('☠  Fatal: Error when connecting to the storage providers! Terminating.  ☠');
        yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
        throw e;
      })
      .then(() => {
        yggdrasil.storage.isConnected = true;
        return Bluebird.resolve();
      })
      .then(() => {
        // Instantiate storage service
        yggdrasil.storageService = new yggdrasil.lib.services.storage(yggdrasil);
      })
      .then(() => {
        // instantiate puppeteer
        if (yggdrasil.config.withPuppeteer) {
          console.time('time: ⏲  Starting Chromium took');
          const pup = new yggdrasil.lib.drivers.puppeteer(yggdrasil);
          return pup.getBrowser()
            .then(browser => {
              yggdrasil.browser = browser;
              console.timeEnd('time: ⏲  Starting Chromium took');
            });
        }
      })
      .then(() => {
        // Instantiate repositories
        console.time('time: ⏲  Repositories instantiation took');
        yggdrasil.repositories = new yggdrasil.lib.models.repositories(yggdrasil);
        console.timeEnd('time: ⏲  Repositories instantiation took');
      })
      .then(() => {
        yggdrasil.fire('startup/core');
        console.timeEnd('time: ⏲  yggdrasil instantiation took');
        return Bluebird.resolve();
      });
  },
  setDefaultMailTransport: () => {
    return new Bluebird(resolve => {
      // instantiate sendmail
      yggdrasil.mailTransporter = nodemailer.createTransport(yggdrasil.config.sendmail);
      yggdrasil.mailTransporter.verify(err => {
        if (err) {
          yggdrasil.logger.error('❗Cannot connect to sendmail server. Not a big deal anyway', err);
        } else {
          yggdrasil.logger.info('⚙  Sendmail server reached');
        }
        yggdrasil.fire('startup/core/sendmail');
      });
      return resolve();
    });
  },
  server: {
    express: {
      base: () => {
        /**
         * Configure Express: base
         */
        return new Bluebird((resolve) => {
          // Base config
          yggdrasil.use(helmet({
            frameguard: false,
            contentSecurityPolicy: {
              directives: {
                defaultSrc: ['\'self\''],
                styleSrc: ['\'self\'', '\'' + yggdrasil.config.authorizedFrontOrigins.join(', ') + '\''],
                upgradeInsecureRequests: true
              }
            }
          }));
          yggdrasil.use(httpLogger('dev'));
          yggdrasil.use(fileUpload());
          yggdrasil.use(bodyParser.urlencoded({ extended: false }));
          yggdrasil.use(bodyParser.json());
          yggdrasil.use(cookieParser(yggdrasil.config.JWTSecret));

          yggdrasil.use((req, res, next) => {
            req.yggdrasil = yggdrasil;
            res.yggdrasil = yggdrasil;
            next();
          });

          resolve();
        });
      },
      CORS: () => {
        /**
         * Configure Express: CORS
         */
        return new Bluebird((resolve) => {
          // middleware to manage CORS
          yggdrasil.use((req, res, next) => {
            res.set({
              'Access-Control-Allow-Origin': req.headers.origin || 'localhost:3000', // dynamic cors allow origin, do not put * here see https://stackoverflow.com/a/42062978
              'Access-Control-Allow-Credentials': 'true',
              'Access-Control-Allow-Methods': 'GET,PUT,POST,DELETE,PATCH,OPTIONS',
              'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control'
            });
            next();
          });

          resolve();
        });
      },
      JWT: () => {
        /**
         * Configure Express : JWT
         */
        return new Bluebird((resolve) => {
          /** Set the yggdrasil JWT secret **/
          yggdrasil.config.JWTSecret = '5b0fc0ed78708601f8d3bd495b0fc0ed78708601f8d3bd4a';
          yggdrasil.config.iss = 'Yggdrasil';
          yggdrasil.logger.info('⚙  JWTSecret =', yggdrasil.config.JWTSecret);
          // middlewares to handle JWT
          yggdrasil.use(
            expressJWT({
              credentialsRequired: true,
              secret: yggdrasil.config.JWTSecret,
              issuer: yggdrasil.config.iss,
              requestProperty: 'session',
              getToken: yggdrasil.sessionsService.getJWT,
              isRevoked: yggdrasil.sessionsService.isRevoked
            })
              .unless({path: [
                '/',
                new RegExp('^/api/+$'),
                new RegExp('^/api/files/avatar/.*'),
                '/socket.io/',
                new RegExp('^/fs.*'),
                new RegExp('^(\\/api\\/auth\\/(?!(logout)).*)'), // everything but logout
                {
                  url: '*',
                  method: ['OPTIONS']
                }
              ]}),
            (err, req, res, next) => {
              if (err instanceof expressJWT.UnauthorizedError) {
                // render the error page
                res
                  .status(err.status)
                  .json({
                    ok: false,
                    cause: 'JWT',
                    rawResponse: err.message,
                    readableResponse: 'There is a problem with the given JWT or no JWT given at all.'
                  });
              } else if (err instanceof Error) {
                res
                  .status(err.status || 500)
                  .json({
                    ok: false,
                    cause: 'Unknown',
                    rawResponse: err,
                    readableResponse: 'Something went wrong during your request treatment.'
                  });
              } else {
                next();
              }
            }
          );

          resolve();
        });
      },
      router: {
        staticFiles: () => {
          /**
           * Configure Express: Router: Static Files
           */
          return new Bluebird((resolve) => {
            // instantiate routes for common static files
            yggdrasil.use('/fs', express.static(path.join(__dirname, 'fileStorage')));
            yggdrasil.logger.info('⚙  Will serve static files from', path.join(__dirname, 'fileStorage'), 'as /fs');

            resolve();
          });
        },
        API: () => {
          /**
           * Configure Express: Router: API
           */
          return new Bluebird((resolve) => {
            const rootDefaultResponse = {
              server: {
                version: 'α',
                lastCommit: yggdrasil.lib.utils.git.getLastCommit(),
                currentTime: moment().toISOString()
              },
              api: {
                version: yggdrasil.config.api.version,
                rootPath: '/api'
              }
            };
            yggdrasil.options('/', (req, res) => {
              res
                .status(200)
                .json(rootDefaultResponse);
            });
            yggdrasil.get('/', (req, res) => {
              res
                .status(200)
                .json(rootDefaultResponse);
            });
            yggdrasil.use('/api', yggdrasil.lib.controllers.router[yggdrasil.config.api.version]);
            yggdrasil.logger.info('⚙  Will serve the API from /api');

            resolve();
          });
        },
        errors: {
          notFound: () => {
            /**
             * Configure Express: Router: Errors: 404
             */
            return new Bluebird((resolve) => {
              yggdrasil.use((req, res) => {
                const err = new Error('Not Found');
                err.status = 404;
                err.message = 'Error 404: Not found.';
                // render the error page
                res
                  .status(err.status)
                  .json({
                    ok: false,
                    cause: 'route',
                    rawResponse: err.message,
                    readableresponse: 'Nothing to see here...'
                  });
              });

              resolve();
            });
          },
          default: () => {
            /**
             * Configure Express: Router: Errors: defaults
             */
            return new Bluebird((resolve) => {
              yggdrasil.use((err, req, res) => {
                // set locals, only providing error in development
                res.locals.message = err.message;
                res.locals.error = req.yggdrasil.get('env') === 'development' ? err : {};

                if (err.name === 'UnauthorizedError') {
                  // JWT error, redirect to /
                  res
                    .status(err.status || 401)
                    .json({
                      ok: false,
                      cause: 'JWT',
                      rawResponse: err.message,
                      readableresponse: 'There is something wrong with your JWT or no JWT given at all.'
                    });
                } else {
                  // render the error page
                  res
                    .status(err.status || 500)
                    .json({
                      ok: false,
                      cause: 'server',
                      rawResponse: err.message,
                      readableresponse: 'Something went wrong while the server was performing actions following your request... or you broke the internet...'
                    });
                }
              });

              resolve();
            });
          }
        }
      }
    },
    httpServerHandlers: {
      onError: (error) => {
        if (error.syscall !== 'listen') {
          throw error;
        }

        const bind = typeof yggdrasil.server.port === 'string'
          ? 'Pipe ' + yggdrasil.server.port
          : 'Port ' + yggdrasil.server.port;

        // handle specific listen errors with friendly messages
        switch (error.code) {
          case 'EACCES':
            yggdrasil.logger.error('❗' + bind + ' requires elevated privileges');
            process.exit(1);
            break;
          case 'EADDRINUSE':
            yggdrasil.logger.error('❗' + bind + ' is already in use');
            process.exit(1);
            break;
          default:
            throw error;
        }
      },
      onListening: () => {
        const
          addr = yggdrasil.server.serverObject.address(),
          bind = typeof addr === 'string'
            ? 'pipe ' + addr
            : 'port ' + addr.port;
        yggdrasil.logger.info('⚙  HTTP server is listening at', yggdrasil.server.domain + ' ' + bind);
        yggdrasil.fire('startup/server/HTTP');
        console.timeEnd('time: ⏲  HTTP Server spawning took ');
      }
    },
    configureExpress: () => {
      yggdrasil.logger.info('☘  Instantiating Express...');

      return yggdrasil.startup.server.express.base()
        .then(() => yggdrasil.startup.server.express.CORS())
        .then(() => yggdrasil.startup.server.express.JWT())
        .then(() => yggdrasil.startup.server.express.router.staticFiles())
        .then(() => yggdrasil.startup.server.express.router.API())
        .then(() => yggdrasil.startup.server.express.router.errors.notFound())
        .then(() => yggdrasil.startup.server.express.router.errors.default());
    },
    instantiateSession: () => {
      return new Bluebird(resolve => {
        yggdrasil.sessionsService = new yggdrasil.lib.services.sessions(yggdrasil);

        resolve();
      });
    },
    spawnHttpServer: () => {
      yggdrasil.logger.info('☘  Spawning the HTTP server...');
      console.time('time: ⏲  HTTP Server spawning took ');

      return new Bluebird((resolve) => {
        let http, server, options;

        if (yggdrasil.server.domain === 'localhost') {
          yggdrasil.logger.info('⚙  Serving from localhost: no security');

          http = require('http');
          server = http.createServer(yggdrasil);
        } else {
          yggdrasil.logger.info('⚙  Not serving from localhost: https is used');

          if (yggdrasil.config.serverCertificate) {
            options = {
              key: yggdrasil.config.serverCertificate.key,
              cert: yggdrasil.config.serverCertificate.cert,
              ca: yggdrasil.config.serverCertificate.ca
            };
          } else {
            options = {
              key: readFileSync('/etc/letsencrypt/live/' + yggdrasil.server.domain + '/privkey.pem'),
              cert: readFileSync('/etc/letsencrypt/live/' + yggdrasil.server.domain + '/cert.pem'),
              ca: readFileSync('/etc/letsencrypt/live/' + yggdrasil.server.domain + '/chain.pem')
            };
          }
          http = require('https');
          server = http.createServer(options, yggdrasil);
        }
        server.listen(yggdrasil.server.port);
        server.on('error', yggdrasil.startup.server.httpServerHandlers.onError);
        server.on('listening', yggdrasil.startup.server.httpServerHandlers.onListening);

        yggdrasil.server.serverObject = server;
        resolve();
      });
    },
    instantiateSocketIo: () => {
      yggdrasil.logger.info('☘  Instantiating SocketIo (attached to HTTP server)...');

      return new Bluebird((resolve) => {
        yggdrasil.socketIoController = new yggdrasil.lib.controllers.socketIo(yggdrasil);
        resolve();
      });
    }
  },
  startServer: (config) => {
    let
      serverStarted = false,
      sendmailReached = false;

    /** Start The yggdrasil ! **/
    console.log('into:', '☘  Instantiating the core components in server mode...');
    console.time('time: ⏲  Starting Server took');
    return yggdrasil.startup.instantiate(config)
      .catch(e => {
        console.error(e);
        process.exit(1);
      })
      .then(() => {
        /** Define the domain and ports **/
        yggdrasil.server.domain = process.env.DOMAIN || 'localhost';
        yggdrasil.logger.info('⚙  Configured domain is', yggdrasil.server.domain);

        if (yggdrasil.server.domain !== 'localhost') {
          yggdrasil.server.protocol = 'https';
          yggdrasil.server.frontPort = '443';
        } else {
          yggdrasil.server.protocol = 'http';
          yggdrasil.server.frontPort = '3000';
        }

        yggdrasil.server.port = yggdrasil.lib.utils.network.normalizePort(process.env.PORT || yggdrasil.config.port || 443);
        yggdrasil.logger.info('⚙  Configured port is', yggdrasil.server.port);

        /** Set the env mode **/
        yggdrasil.set('env', process.env.ENV || 'development');

        /** Listen o events to know when the server is really started **/
        yggdrasil.listenOnce('startup/core/sendmail', () => {
          sendmailReached = true;
          yggdrasil.fire('startup/somethingOk');
        });
        yggdrasil.listenOnce('startup/server/HTTP', () => {
          serverStarted = true;
          yggdrasil.fire('startup/somethingOk');
        });

        yggdrasil.listen('startup/somethingOk', () => {
          if (serverStarted && sendmailReached) {
            console.timeEnd('time: ⏲  Starting Server took');
            yggdrasil.logger.info(' \n\n\n' +
              '   __  __                         __   ____                    _             __\n' +
              '  / / / /___     ____ _____  ____/ /  / __ \\__  ______  ____  (_)___  ____ _/ /\n' +
              ' / / / / __ \\   / __ `/ __ \\/ __  /  / /_/ / / / / __ \\/ __ \\/ / __ \\/ __ `/ / \n' +
              '/ /_/ / /_/ /  / /_/ / / / / /_/ /  / _, _/ /_/ / / / / / / / / / / / /_/ /_/  \n' +
              '\\____/ .___/   \\__,_/_/ /_/\\__,_/  /_/ |_|\\__,_/_/ /_/_/ /_/_/_/ /_/\\__, (_)   \n' +
              '    /_/                                                            /____/      \n\n\n'+
              '_______________________________________________________________________________\n');
            yggdrasil.stopListening('startup/somethingOk');
          }
        });
      })
      .then(() => yggdrasil.startup.setDefaultMailTransport())
      .then(() => yggdrasil.startup.server.instantiateSession())
      .then(() => yggdrasil.startup.server.configureExpress())
      .then(() => yggdrasil.startup.server.spawnHttpServer())
      .then(() => yggdrasil.startup.server.instantiateSocketIo())
      .catch(e => {
        yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
        yggdrasil.logger.error('☠  Fatal: Error when starting the server!                 Terminating.  ☠');
        yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
        console.error(e);
        process.exit(1);
      })
      .then(() => {
        yggdrasil.logger.info('☘  Everything have been instantiated, awaiting for the last things to be ready...');
        return Bluebird.resolve(yggdrasil);
      });
  },
  startFunctionalTestingServer: (fixtures, config) => {
    const defaultConfig = require('rc')('yggdrasil', require('./defaultConfig'));

    yggdrasil.fixtures = fixtures;

    /** writes the current server PID into a file so that the server can be interrupted or killed easily **/
    writeFileSync('/var/run/yggdrasilTestingServer.pid', process.pid);

    /** replace defaultConfig parts with testing config **/
    config = merge(defaultConfig, config);

    return yggdrasil.startup.startServer(config)
      .then(_yggdrasil => configureYggdrasilForFunctionalTesting(_yggdrasil));
  }
};

/**
 * Allow to kill the current instance of Yggdrasil
 * @param _yggdrasil
 * @param callback
 * @returns {Promise<void>}
 */
yggdrasil.kill = async (_yggdrasil, callback) => {
  _yggdrasil = await _yggdrasil.cleanupFunctionalTestingdata(_yggdrasil);
  _yggdrasil.server.serverObject.close(async function () {
    _yggdrasil.logger.info('The HTTP server is now closed');
    _yggdrasil.logger.info('Disconnect from Redis and Mongo...');
    await _yggdrasil.storage.mongo.disconnect();
    await _yggdrasil.storage.redis.disconnect();
    _yggdrasil.logger.info('Yggdrasil will die soon.');

    if (callback) {
      callback();
    }
  });
};

/**
 * Reconfigure the current yggdrasil instance repositories to use the testing indexes and inject fixtures into the database
 */
function configureYggdrasilForFunctionalTesting (_yggdrasil) {
  try {
    _yggdrasil.logger.info('!!! Injecting fixtures');

    if (_yggdrasil.fixtures === undefined) {
      throw new Error('configureYggdrasilForFunctionalTesting: you should have injected fixtures into yggdrasil.fixtures first');
    }
    Object.keys(yggdrasil.repositories).forEach(key => {
      _yggdrasil.repositories[key].setIndexCollection('testing_' + yggdrasil.repositories[key].index);
      _yggdrasil.logger.info('!!! injecting fixtures into', _yggdrasil.repositories[key].index, _yggdrasil.repositories[key].collection);
    });

    // injects fixtures
    Object.keys(yggdrasil.fixtures).forEach(index => {
      Object.keys(yggdrasil.fixtures[index]).forEach(collection => {
        _yggdrasil.fixtures[index][collection].forEach(async item => {
          await _yggdrasil.storageService.set({
            index: index,
            collection: collection,
            body: item
          });
        });
      });
    });

    _yggdrasil.functionalTestingInitDone = true;

    _yggdrasil.logger.info('!!! Fixtures injected');
  } catch (e) {
    console.log(e);
    process.exit(1);
  }

  /**
   * Helps to cleanup the testing fixtures
   * @param yggdrasil
   * @param fixtures
   */
  _yggdrasil.cleanupFunctionalTestingdata = async (currentInstance) => {
    currentInstance.logger.info('!!! Deleting fixtures');
    if (currentInstance.fixtures === undefined) {
      throw new Error('configureYggdrasilForFunctionalTesting: you should have injected fixtures into yggdrasil.fixtures first');
    }
    currentInstance.logger.info('>>> Indexes to delete', Object.keys(currentInstance.fixtures));

    try {
      currentInstance.storageService.dropIndexes(Object.keys(currentInstance.fixtures));
    } catch (e) {
      console.log(e);
    }

    currentInstance.logger.info('!!! Fixtures deleted');

    return Bluebird.resolve(currentInstance);
  };

  return Bluebird.resolve(_yggdrasil);
}

/**
 * Kill the current instance when the process receive the SIGTERM signal
 */
process.on('SIGINT', () => {
  yggdrasil.kill(yggdrasil);
});

module.exports = yggdrasil;
