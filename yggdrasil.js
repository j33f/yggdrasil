'use strict';

const ObjectID = require('mongodb').ObjectID;
const express = require('express');

console.log('.-.  .-..---.  .---. .----. .----.   .--.   .----..-..-.   \n' +
' \\ \\/ //   __}/   __}| {}  \\| {}  } / {} \\ { {__  | || |   \n' +
'  }  { \\  {_ }\\  {_ }|     /| .-. \\/  /\\  \\.-._} }| || `--.\n' +
'  `--\'  `---\'  `---\' `----\' `-\' `-\'`-\'  `-\'`----\' `-\'`----\'');

// Yggdrasil is an express instance
let yggdrasil = express();
yggdrasil.rootPath = __dirname;

/**
 * Configuration loader
 * @param jsonConfig -  the specific json configuration (allow specific config for testing purposes)
 */
yggdrasil.loadConfig = jsonConfig => {
  if (jsonConfig) {
    yggdrasil.config = jsonConfig;
  } else {
    yggdrasil.config = require('rc')('yggdrasil', require('./defaultConfig'));
  }
};

/**
 * Returns an UUID generated by Mongo ObjectID
 * returns a real ObjectID
 * @param {boolean} returnString -  if true, send the hex string from ObjectID
 * @returns {string|ObjectID}
 */
yggdrasil.uuid = (returnString = false) => {
  let theUuid = new ObjectID();
  if (!returnString) {
    return theUuid;
  }
  return theUuid.toHexString();
};

/** Load the main Lib **/
yggdrasil.lib = require('./lib');

/***********************************************************************************************************************
 *
 * YGGDRASIL DEFINE METHODS TO INSTANTIATE CORE COMPONENTS
 *
 **********************************************************************************************************************/
/*yggdrasil.startup = {
  instantiate: async (config) => {
    /!**
     * Instantiate core services
     *!/
    /!** Load the config **!/
    console.time('time: ⏲  Pre-startup took');
    console.time('time: ⏲  Load config took');
    yggdrasil.loadConfig(config);
    console.timeEnd('time: ⏲  Load config took');

    /!** Instantiate and configure the logger **!/
    yggdrasil.logger = logger;
    yggdrasil.logger.level = yggdrasil.config.logger.level || 'silly';

    /!** Prepares the yggdrasil to be served if needed **!/
    yggdrasil.server = {};

    /!** Adds events capabilities to the yggdrasil **!/
    yggdrasil.events = new yggdrasil.lib.controllers.events(yggdrasil); // adds some methods to yggdrasil as shortcuts: see controller

    /!** Define storage providers **!/
    console.time('time: ⏲  Defining Storages took');
    yggdrasil.storage = {
      mongo: new yggdrasil.lib.drivers.mongo(yggdrasil, yggdrasil.config.mongo),
      redis: new yggdrasil.lib.drivers.redis(yggdrasil, yggdrasil.config.redis),
      isConnected: false
    };
    console.timeEnd('time: ⏲  Defining Storages took');

    if (yggdrasil.config.proxyMesh.activated) {
      yggdrasil.proxy = new yggdrasil.lib.drivers.proxyMesh(yggdrasil);
      yggdrasil.logger.info('⚙  ProxyMesh instantiated');
    }

    yggdrasil.logger.info('⚡ New yggdrasil ready to be instantiated...');
    console.timeEnd('time: ⏲  Pre-startup took');

    console.time('time: ⏲  yggdrasil instantiation took');
    try {
      await yggdrasil.storage.mongo.connect();
      await yggdrasil.storage.redis.connect();
    } catch (e) {
      yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
      yggdrasil.logger.error('☠  Fatal: Error when connecting to the storage providers! Terminating.  ☠');
      yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
      throw e;
    }

    yggdrasil.storage.isConnected = true;
    yggdrasil.storageService = new yggdrasil.lib.services.storage(yggdrasil);

    if (yggdrasil.config.withPuppeteer) {
      console.time('time: ⏲  Starting Chromium took');
      const pup = new yggdrasil.lib.drivers.puppeteer(yggdrasil);
      yggdrasil.browser = await pup.getBrowser();
      console.timeEnd('time: ⏲  Starting Chromium took');
    }

    console.time('time: ⏲  Repositories instantiation took');
    yggdrasil.repositories = new yggdrasil.lib.models.repositories(yggdrasil);
    console.timeEnd('time: ⏲  Repositories instantiation took');

    yggdrasil.fire('startup/core');
    console.timeEnd('time: ⏲  yggdrasil instantiation took');
  },
  setDefaultMailTransport: async () => {
    yggdrasil.mailTransporter = nodemailer.createTransport(yggdrasil.config.sendmail);
    yggdrasil.mailTransporter.verify(err => {
      if (err) {
        yggdrasil.logger.error('❗Cannot connect to sendmail server. Not a big deal anyway', err);
      } else {
        yggdrasil.logger.info('⚙  Sendmail server reached');
      }
      yggdrasil.fire('startup/core/sendmail');
    });
  },
  server: {
    express: {
      base: async () => {
        /!**
         * Configure Express: base
         *!/
        // Base config
        yggdrasil.use(helmet({
          frameguard: false,
          contentSecurityPolicy: {
            directives: {
              defaultSrc: ['\'self\''],
              styleSrc: ['\'self\'', '\'' + yggdrasil.config.authorizedFrontOrigins.join(', ') + '\''],
              upgradeInsecureRequests: true
            }
          }
        }));
        yggdrasil.use(httpLogger('dev'));
        yggdrasil.use(fileUpload());
        yggdrasil.use(bodyParser.urlencoded({ extended: false }));
        yggdrasil.use(bodyParser.json());
        yggdrasil.use(cookieParser(yggdrasil.config.JWTSecret));

        yggdrasil.use((req, res, next) => {
          req.yggdrasil = yggdrasil;
          res.yggdrasil = yggdrasil;
          next();
        });
      },
      CORS: async () => {
        /!**
         * Configure Express: CORS
         *!/
        // middleware to manage CORS
        yggdrasil.use((req, res, next) => {
          res.set({
            'Access-Control-Allow-Origin': req.headers.origin || 'localhost:3000', // dynamic cors allow origin, do not put * here see https://stackoverflow.com/a/42062978
            'Access-Control-Allow-Credentials': 'true',
            'Access-Control-Allow-Methods': 'GET,PUT,POST,DELETE,PATCH,OPTIONS',
            'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control'
          });
          next();
        });
      },
      JWT: async () => {
        /!**
         * Configure Express : JWT
         *!/
        /!** Set the yggdrasil JWT secret **!/
        yggdrasil.config.JWTSecret = '5b0fc0ed78708601f8d3bd495b0fc0ed78708601f8d3bd4a';
        yggdrasil.config.iss = 'Yggdrasil';
        yggdrasil.logger.info('⚙  JWTSecret =', yggdrasil.config.JWTSecret);
        // middlewares to handle JWT
        yggdrasil.use(
          expressJWT({
            credentialsRequired: true,
            secret: yggdrasil.config.JWTSecret,
            issuer: yggdrasil.config.iss,
            requestProperty: 'session',
            getToken: yggdrasil.sessionsService.getJWT,
            isRevoked: yggdrasil.sessionsService.isRevoked
          })
            .unless({
              path: [
                '/',
                new RegExp('^/api/+$'),
                new RegExp('^/api/files/avatar/.*'),
                '/socket.io/',
                new RegExp('^/fs.*'),
                new RegExp('^(\\/api\\/auth\\/(?!(logout)).*)'), // everything but logout
                {
                  url: '*',
                  method: ['OPTIONS']
                }
              ]
            }),
          (err, req, res, next) => {
            if (err instanceof expressJWT.UnauthorizedError) {
              // render the error page
              res
                .status(err.status)
                .json({
                  ok: false,
                  cause: 'JWT',
                  rawResponse: err.message,
                  readableResponse: 'There is a problem with the given JWT or no JWT given at all.'
                });
            } else if (err instanceof Error) {
              res
                .status(err.status || 500)
                .json({
                  ok: false,
                  cause: 'Unknown',
                  rawResponse: err,
                  readableResponse: 'Something went wrong during your request treatment.'
                });
            } else {
              next();
            }
          }
        );
      },
      router: {
        staticFiles: async () => {
          /!**
           * Configure Express: Router: Static Files
           *!/
          // instantiate routes for common static files
          yggdrasil.use('/fs', express.static(path.join(__dirname, 'fileStorage')));
          yggdrasil.logger.info('⚙  Will serve static files from', path.join(__dirname, 'fileStorage'), 'as /fs');
        },
        API: async () => {
          /!**
           * Configure Express: Router: API
           *!/
          const rootDefaultResponse = {
            server: {
              version: 'α',
              lastCommit: yggdrasil.lib.utils.git.getLastCommit(),
              currentTime: moment().toISOString()
            },
            api: {
              version: yggdrasil.config.api.version,
              rootPath: '/api'
            }
          };
          yggdrasil.options('/', (req, res) => {
            res
              .status(200)
              .json(rootDefaultResponse);
          });
          yggdrasil.get('/', (req, res) => {
            res
              .status(200)
              .json(rootDefaultResponse);
          });
          yggdrasil.use('/api', yggdrasil.lib.controllers.router[yggdrasil.config.api.version]);
          yggdrasil.logger.info('⚙  Will serve the API from /api');
        },
        errors: {
          notFound: async () => {
            /!**
             * Configure Express: Router: Errors: 404
             *!/
            yggdrasil.use((req, res) => {
              const err = new Error('Not Found');
              err.status = 404;
              err.message = 'Error 404: Not found.';
              // render the error page
              res
                .status(err.status)
                .json({
                  ok: false,
                  cause: 'route',
                  rawResponse: err.message,
                  readableresponse: 'Nothing to see here...'
                });
            });
          },
          default: async () => {
            /!**
             * Configure Express: Router: Errors: defaults
             *!/
            yggdrasil.use((err, req, res) => {
              // set locals, only providing error in development
              res.locals.message = err.message;
              res.locals.error = req.yggdrasil.get('env') === 'development' ? err : {};

              if (err.name === 'UnauthorizedError') {
                // JWT error, redirect to /
                res
                  .status(err.status || 401)
                  .json({
                    ok: false,
                    cause: 'JWT',
                    rawResponse: err.message,
                    readableresponse: 'There is something wrong with your JWT or no JWT given at all.'
                  });
              } else {
                // render the error page
                res
                  .status(err.status || 500)
                  .json({
                    ok: false,
                    cause: 'server',
                    rawResponse: err.message,
                    readableresponse: 'Something went wrong while the server was performing actions following your request... or you broke the internet...'
                  });
              }
            });
          }
        }
      }
    },
    httpServerHandlers: {
      onError: (error) => {
        if (error.syscall !== 'listen') {
          throw error;
        }

        const bind = typeof yggdrasil.server.port === 'string'
          ? 'Pipe ' + yggdrasil.server.port
          : 'Port ' + yggdrasil.server.port;

        // handle specific listen errors with friendly messages
        switch (error.code) {
          case 'EACCES':
            yggdrasil.logger.error('❗' + bind + ' requires elevated privileges');
            process.exit(1);
            break;
          case 'EADDRINUSE':
            yggdrasil.logger.error('❗' + bind + ' is already in use');
            process.exit(1);
            break;
          default:
            throw error;
        }
      },
      onListening: () => {
        const
          addr = yggdrasil.server.serverObject.address(),
          bind = typeof addr === 'string'
            ? 'pipe ' + addr
            : 'port ' + addr.port;
        yggdrasil.logger.info('⚙  HTTP server is listening at', yggdrasil.server.domain + ' ' + bind);
        yggdrasil.fire('startup/server/HTTP');
        console.timeEnd('time: ⏲  HTTP Server spawning took ');
      }
    },
    configureExpress: async () => {
      yggdrasil.logger.info('☘  Instantiating Express...');

      await yggdrasil.startup.server.express.base();
      await yggdrasil.startup.server.express.CORS();
      await yggdrasil.startup.server.express.JWT();
      await yggdrasil.startup.server.express.router.staticFiles();
      await yggdrasil.startup.server.express.router.API();
      await yggdrasil.startup.server.express.router.errors.notFound();
      await yggdrasil.startup.server.express.router.errors.default();
    },
    instantiateSession: async () => {
      yggdrasil.sessionsService = new yggdrasil.lib.services.sessions(yggdrasil);
    },
    spawnHttpServer: async () => {
      yggdrasil.logger.info('☘  Spawning the HTTP server...');
      console.time('time: ⏲  HTTP Server spawning took ');

      let http, server, options;

      if (yggdrasil.server.domain === 'localhost') {
        yggdrasil.logger.info('⚙  Serving from localhost: no security');

        http = require('http');
        server = http.createServer(yggdrasil);
      } else {
        yggdrasil.logger.info('⚙  Not serving from localhost: https is used');

        if (yggdrasil.config.serverCertificate) {
          options = {
            key: yggdrasil.config.serverCertificate.key,
            cert: yggdrasil.config.serverCertificate.cert,
            ca: yggdrasil.config.serverCertificate.ca
          };
        } else {
          options = {
            key: readFileSync('/etc/letsencrypt/live/' + yggdrasil.server.domain + '/privkey.pem'),
            cert: readFileSync('/etc/letsencrypt/live/' + yggdrasil.server.domain + '/cert.pem'),
            ca: readFileSync('/etc/letsencrypt/live/' + yggdrasil.server.domain + '/chain.pem')
          };
        }
        http = require('https');
        server = http.createServer(options, yggdrasil);
      }
      server.listen(yggdrasil.server.port);
      server.on('error', yggdrasil.startup.server.httpServerHandlers.onError);
      server.on('listening', yggdrasil.startup.server.httpServerHandlers.onListening);

      yggdrasil.server.serverObject = server;
    },
    instantiateSocketIo: async () => {
      yggdrasil.logger.info('☘  Instantiating SocketIo (attached to HTTP server)...');

      yggdrasil.socketIoController = new yggdrasil.lib.controllers.socketIo(yggdrasil);
    }
  },
  startServer: async (config) => {
    let
      serverStarted = false,
      sendmailReached = false;

    /!** Start The yggdrasil ! **!/
    console.log('into:', '☘  Instantiating the core components in server mode...');
    console.time('time: ⏲  Starting Server took');
    try {
      await yggdrasil.startup.instantiate(config);
    } catch(e) {
      console.error(e);
      process.exit(1);
    }

    /!** Define the domain and ports **!/
    yggdrasil.server.domain = process.env.DOMAIN || 'localhost';
    yggdrasil.logger.info('⚙  Configured domain is', yggdrasil.server.domain);

    if (yggdrasil.server.domain !== 'localhost') {
      yggdrasil.server.protocol = 'https';
      yggdrasil.server.frontPort = '443';
    } else {
      yggdrasil.server.protocol = 'http';
      yggdrasil.server.frontPort = '3000';
    }

    yggdrasil.server.port = yggdrasil.lib.utils.network.normalizePort(process.env.PORT || yggdrasil.config.port || 443);
    yggdrasil.logger.info('⚙  Configured port is', yggdrasil.server.port);

    /!** Set the env mode **!/
    yggdrasil.set('env', process.env.ENV || 'development');

    /!** Listen o events to know when the server is really started **!/
    yggdrasil.listenOnce('startup/core/sendmail', () => {
      sendmailReached = true;
      yggdrasil.fire('startup/somethingOk');
    });
    yggdrasil.listenOnce('startup/server/HTTP', () => {
      serverStarted = true;
      yggdrasil.fire('startup/somethingOk');
    });

    yggdrasil.listen('startup/somethingOk', () => {
      if (serverStarted && sendmailReached) {
        console.timeEnd('time: ⏲  Starting Server took');
        yggdrasil.logger.info(' \n\n\n' +
          '   __  __                         __   ____                    _             __\n' +
          '  / / / /___     ____ _____  ____/ /  / __ \\__  ______  ____  (_)___  ____ _/ /\n' +
          ' / / / / __ \\   / __ `/ __ \\/ __  /  / /_/ / / / / __ \\/ __ \\/ / __ \\/ __ `/ / \n' +
          '/ /_/ / /_/ /  / /_/ / / / / /_/ /  / _, _/ /_/ / / / / / / / / / / / /_/ /_/  \n' +
          '\\____/ .___/   \\__,_/_/ /_/\\__,_/  /_/ |_|\\__,_/_/ /_/_/ /_/_/_/ /_/\\__, (_)   \n' +
          '    /_/                                                            /____/      \n\n\n'+
          '_______________________________________________________________________________\n');
        yggdrasil.stopListening('startup/somethingOk');
      }
    });

    try {
      await yggdrasil.startup.setDefaultMailTransport();
      await yggdrasil.startup.server.instantiateSession();
      await yggdrasil.startup.server.configureExpress();
      await yggdrasil.startup.server.spawnHttpServer();
      await yggdrasil.startup.server.instantiateSocketIo();
    } catch(e) {
      yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
      yggdrasil.logger.error('☠  Fatal: Error when starting the server!                 Terminating.  ☠');
      yggdrasil.logger.error('☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠ ☠');
      console.error(e);
      process.exit(1);
    }

    yggdrasil.logger.info('☘  Everything have been instantiated, awaiting for the last things to be ready...');
    return yggdrasil;
  },
  startFunctionalTestingServer: async (fixtures, config) => {
    try {
      const defaultConfig = require('rc')('yggdrasil', require('./defaultConfig'));

      yggdrasil.fixtures = fixtures;

      /!** writes the current server PID into a file so that the server can be interrupted or killed easily **!/
      writeFileSync('/var/run/yggdrasilTestingServer.pid', process.pid);

      /!** replace defaultConfig parts with testing config **!/
      config = merge(defaultConfig, config);

      const _yggdrasil = await yggdrasil.startup.startServer(config);
      return await configureYggdrasilForFunctionalTesting(_yggdrasil);
    } catch (e) {
      console.log(e);
      process.exit(1);
    }
  }
};*/

yggdrasil.lib.core.startup(yggdrasil);

/**
 * Allow to kill the current instance of Yggdrasil
 * @param _yggdrasil
 * @param callback
 * @returns {Promise<void>}
 */
yggdrasil.kill = async (_yggdrasil, callback) => {
  _yggdrasil = await _yggdrasil.cleanupFunctionalTestingdata(_yggdrasil);
  _yggdrasil.server.serverObject.close(async function () {
    _yggdrasil.logger.info('The HTTP server is now closed');
    _yggdrasil.logger.info('Disconnect from Redis and Mongo...');
    await _yggdrasil.storage.mongo.disconnect();
    await _yggdrasil.storage.redis.disconnect();
    _yggdrasil.logger.info('Yggdrasil will die soon.');

    if (callback) {
      callback();
    }
  });
};
/**
 * Kill the current instance when the process receive the SIGTERM signal
 */
process.on('SIGINT', () => {
  yggdrasil.kill(yggdrasil);
});

module.exports = yggdrasil;